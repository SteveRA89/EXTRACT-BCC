Phase: Margins
Input: Dimension Micro_deep_margin Micro_peripheral_margin Sentence MarginWordDistances ClockFace NewLine Separator Micro_thickness Token
Options: control=appelt

//Maybe these should go to DeepMeasurement and PeripheralMeasurements

Rule: DeepMargin
Priority:100
(
    ({Micro_deep_margin})
    ({ClockFace})?
    ({Dimension})

):match
-->
:match.Measurements = { rule = DeepMargin, MeasurementType = "DeepClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
DeepClockPosition = :match.ClockFace.time}

Rule: DeepMargina
Priority:100
(
    ({Micro_deep_margin})
    ({Dimension})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = DeepMargina, MeasurementType = "DeepClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
DeepClockPosition = :match.ClockFace.time}

Rule: DeepMargin2
Priority:100
(
    ({Dimension})
    ({ClockFace})?
    ({Micro_deep_margin})

):match
-->
:match.Measurements = { rule = DeepMargin2, MeasurementType = "DeepClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
DeepClockPosition = :match.ClockFace.time}

Rule: DeepMargin2a
Priority:100
(
    ({Dimension})
    ({Micro_deep_margin})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = DeepMargin2a, MeasurementType = "DeepClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
DeepClockPosition = :match.ClockFace.time}

Rule: PeripheralMargin
Priority:100
(
    ({Micro_peripheral_margin})
    ({ClockFace})?
    ({Dimension})

):match
-->
:match.Measurements = { rule = PeripheralMargin, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
PeripheralClockPosition = :match.ClockFace.time}

Rule: PeripheralMargina
Priority:100
(
    ({Micro_peripheral_margin})
    ({Dimension})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = PeripheralMargina, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
PeripheralClockPosition = :match.ClockFace.time}

Rule: PeripheralMargin2
Priority:100
(
    ({Dimension})
    ({ClockFace})?
    ({Micro_peripheral_margin})

):match
-->
:match.Measurements = { rule = PeripheralMargin2, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
PeripheralClockPosition = :match.ClockFace.time}

Rule: PeripheralMargin2a
Priority:100
(
    ({Dimension})
    ({Micro_peripheral_margin})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = PeripheralMargin2a, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
PeripheralClockPosition = :match.ClockFace.time}

Rule: DeepMarginWords1
Priority:100
(
    ({Micro_deep_margin})
    ({ClockFace})?
    ({MarginWordDistances})

):match
-->
:match.Measurements = { rule = DeepMarginWords1, MeasurementType = "DeepClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
DeepClockPosition = :match.ClockFace.time}

Rule: DeepMarginWords1a
Priority:100
(
    ({Micro_deep_margin})
    ({MarginWordDistances})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = DeepMarginWords1a, MeasurementType = "DeepClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
DeepClockPosition = :match.ClockFace.time}

Rule: DeepMarginWords2
Priority:100
(
    ({MarginWordDistances})
    ({ClockFace})?
    ({Micro_deep_margin})

):match
-->
:match.Measurements = { rule = DeepMarginWords2, MeasurementType = "DeepClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
DeepClockPosition = :match.ClockFace.time}

Rule: DeepMarginWords2a
Priority:100
(
    ({MarginWordDistances})
    ({Micro_deep_margin})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = DeepMarginWords2a, MeasurementType = "DeepClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
DeepClockPosition = :match.ClockFace.time}

Rule: PeripheralMarginWords1
Priority:100
(
    ({Micro_peripheral_margin})
    ({ClockFace})?
    ({MarginWordDistances})

):match
-->
:match.Measurements = { rule = PeripheralMarginWords1, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
PeripheralClockPosition = :match.ClockFace.time}

Rule: PeripheralMarginWords1a
Priority:100
(
    ({Micro_peripheral_margin})
    ({MarginWordDistances})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = PeripheralMarginWords1a, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
PeripheralClockPosition = :match.ClockFace.time}

Rule: PeripheralMarginWords2
Priority:100
(
    ({MarginWordDistances})
    ({ClockFace})?
    ({Micro_peripheral_margin})

):match
-->
:match.Measurements = { rule = PeripheralMarginWords2, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
PeripheralClockPosition = :match.ClockFace.time}

Rule: PeripheralMarginWords2a
Priority:100
(
    ({MarginWordDistances})
    ({Micro_peripheral_margin})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = PeripheralMarginWords2, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
PeripheralClockPosition = :match.ClockFace.time}

//Deep first

Rule: ConcatenatedMargins1
Priority:100
(
    ({Dimension}):n1
    ({Micro_thickness}):n1
    ({Token})?
    ({Separator})?
    ({ClockFace})?:n1
    ({Dimension}):n2
    ({Micro_peripheral_margin}):n2
    ({ClockFace})?:n2

):match
-->
:match.Measurements = { rule = ConcatenatedMargins1, 
MeasurementType1 = "DeepClearance", 
N1 = :n1.Dimension.N1, 
MeasurementUnit1 = :n1.Dimension.units,
DeepClockPosition1 = :n1.ClockFace.time,
MeasurementType2 = "PeripheralClearance", 
N2 = :n2.Dimension.N2, 
MeasurementUnit2 = :n2.Dimension.units,
PeripheralClockPosition2 = :n2.ClockFace.time}

//Peripheral first

Rule: ConcatenatedMargins2
Priority:100
(
    ({Dimension}):n1
    ({Micro_peripheral_margin})
    ({Token})?
    ({Separator})?
    ({ClockFace})?:n1
    ({Dimension}):n2
    ({Micro_deep_margin})
    ({ClockFace})?:n2

):match
-->
:match.Measurements = { rule = ConcatenatedMargins2, 
MeasurementType1 = "PeripheralClearance", 
N1 = :n1.Dimension.N1, 
MeasurementUnit1 = :n1.Dimension.units,
PeripheralClockPosition1 = :n1.ClockFace.time,
MeasurementType2 = "DeepClearance", 
N2 = :n2.Dimension.N2, 
MeasurementUnit2 = :n2.Dimension.units,
DeepClockPosition2 = :n2.ClockFace.time}