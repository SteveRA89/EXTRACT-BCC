Phase: Margins
Input: Dimension Micro_deep_margin Micro_peripheral_margin Sentence MarginWordDistances ClockFace NewLine Separator Micro_thickness
Options: control=appelt

//Maybe these should go to DeepMeasurement and PeripheralMeasurements

Rule: DeepMargin
Priority:100
(
    ({Micro_deep_margin})
    ({ClockFace})?
    ({Dimension})

):match
-->
:match.Measurements = { rule = DeepMargin, MeasurementType = "DeepClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
DeepClockPosition = :match.ClockFace.time}

Rule: DeepMargina
Priority:100
(
    ({Micro_deep_margin})
    ({Dimension})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = DeepMargina, MeasurementType = "DeepClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
DeepClockPosition = :match.ClockFace.time}

Rule: DeepMargin2
Priority:100
(
    ({Dimension})
    ({ClockFace})?
    ({Micro_deep_margin})

):match
-->
:match.Measurements = { rule = DeepMargin2, MeasurementType = "DeepClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
DeepClockPosition = :match.ClockFace.time}

Rule: DeepMargin2a
Priority:100
(
    ({Dimension})
    ({Micro_deep_margin})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = DeepMargin2a, MeasurementType = "DeepClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
DeepClockPosition = :match.ClockFace.time}

Rule: PeripheralMargin
Priority:100
(
    ({Micro_peripheral_margin})
    ({ClockFace})?
    ({Dimension})

):match
-->
:match.Measurements = { rule = PeripheralMargin, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
PeripheralClockPosition = :match.ClockFace.time}

Rule: PeripheralMargina
Priority:100
(
    ({Micro_peripheral_margin})
    ({Dimension})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = PeripheralMargina, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
PeripheralClockPosition = :match.ClockFace.time}

Rule: PeripheralMargin2
Priority:100
(
    ({Dimension})
    ({ClockFace})?
    ({Micro_peripheral_margin})

):match
-->
:match.Measurements = { rule = PeripheralMargin2, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
PeripheralClockPosition = :match.ClockFace.time}

Rule: PeripheralMargin2a
Priority:100
(
    ({Dimension})
    ({Micro_peripheral_margin})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = PeripheralMargin2a, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.Dimension.N1, 
MeasurementUnit = :match.Dimension.units,
PeripheralClockPosition = :match.ClockFace.time}

Rule: DeepMarginWords1
Priority:100
(
    ({Micro_deep_margin})
    ({ClockFace})?
    ({MarginWordDistances})

):match
-->
:match.Measurements = { rule = DeepMarginWords1, MeasurementType = "DeepClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
DeepClockPosition = :match.ClockFace.time}

Rule: DeepMarginWords1a
Priority:100
(
    ({Micro_deep_margin})
    ({MarginWordDistances})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = DeepMarginWords1a, MeasurementType = "DeepClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
DeepClockPosition = :match.ClockFace.time}

Rule: DeepMarginWords2
Priority:100
(
    ({MarginWordDistances})
    ({ClockFace})?
    ({Micro_deep_margin})

):match
-->
:match.Measurements = { rule = DeepMarginWords2, MeasurementType = "DeepClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
DeepClockPosition = :match.ClockFace.time}

Rule: DeepMarginWords2a
Priority:100
(
    ({MarginWordDistances})
    ({Micro_deep_margin})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = DeepMarginWords2a, MeasurementType = "DeepClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
DeepClockPosition = :match.ClockFace.time}

Rule: PeripheralMarginWords1
Priority:100
(
    ({Micro_peripheral_margin})
    ({ClockFace})?
    ({MarginWordDistances})

):match
-->
:match.Measurements = { rule = PeripheralMarginWords1, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
PeripheralClockPosition = :match.ClockFace.time}

Rule: PeripheralMarginWords1a
Priority:100
(
    ({Micro_peripheral_margin})
    ({MarginWordDistances})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = PeripheralMarginWords1a, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
PeripheralClockPosition = :match.ClockFace.time}

Rule: PeripheralMarginWords2
Priority:100
(
    ({MarginWordDistances})
    ({ClockFace})?
    ({Micro_peripheral_margin})

):match
-->
:match.Measurements = { rule = PeripheralMarginWords2, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
PeripheralClockPosition = :match.ClockFace.time}

Rule: PeripheralMarginWords2a
Priority:100
(
    ({MarginWordDistances})
    ({Micro_peripheral_margin})
    ({ClockFace})?

):match
-->
:match.Measurements = { rule = PeripheralMarginWords2, MeasurementType = "PeripheralClearance", 
MeasurementValue = :match.MarginWordDistances.Value, 
MeasurementUnit = "mm",
PeripheralClockPosition = :match.ClockFace.time}

// Note on both these Rules, I would add them to a new rule that only picked up either the first (or second) part of the thing
// So it would kind of be separated into two annotations, a Deep clearance and a Peripheral clearance, this will be easier to use in the future.
// As you have to do two annotations in markup. - Example from letter 5 = "Completely excised with 1.3mm deep and 3mm lateral margins."

// The problem wasn't with the multiple :n1/:n2 in the end - but I have fixed it here and it is still a good idea to group them
// Also removed Token as you dont need to be that specific and it now picks up - "The lesion is narrowly excised by 0.2mm at the deep margin" from letter 5

//Deep first

Rule: ConcatenatedMargins1
Priority:100
(
    ({Dimension}):n1
    ({Micro_thickness}):n1
    ({Token})?
    ({Separator})?
    ({ClockFace})?:n1
    ({Dimension}):n2
    ({Micro_peripheral_margin}):n2
    ({ClockFace})?:n2
):match
-->
:match.Measurements = { rule = ConcatenatedMargins1, 
MeasurementType1 = "DeepClearance", 
N1 = :n1.Dimension.N1, 
MeasurementUnit1 = :n1.Dimension.units,
DeepClockPosition1 = :n1.ClockFace.time,
MeasurementType2 = "PeripheralClearance", 
N2 = :n2.Dimension.N1, //This has to be N1 as it is the first Measurement of the second dimension - so you are taking N1 (first measurement) into N2 (second) for this mesasurement
MeasurementUnit2 = :n2.Dimension.units,
PeripheralClockPosition2 = :n2.ClockFace.time}

//Peripheral first

Rule: ConcatenatedMargins2
Priority:100
(
    ({Dimension}):n1 //Because you have used :n1 (and :n2) twice here, its not sure which one to use. 
    ({Micro_peripheral_margin})
    ({Token})?
    ({Separator})?
    ({ClockFace})?:n1
    ({Dimension}):n2
    ({Micro_deep_margin})
    ({ClockFace})?:n2

):match
-->
:match.Measurements = { rule = ConcatenatedMargins2, 
MeasurementType1 = "PeripheralClearance", 
N1 = :n1.Dimension.N1, 
MeasurementUnit1 = :n1.Dimension.units,
PeripheralClockPosition1 = :n1.ClockFace.time,
MeasurementType2 = "DeepClearance", 
N2 = :n2.Dimension.N1, 
MeasurementUnit2 = :n2.Dimension.units,
DeepClockPosition2 = :n2.ClockFace.time}

//here is the error message I sent in Slack.
//I've added comments below with the numbers being each line of the error. Delete this after you understand it
/*

file:/C:/Users/huw.strafford/Documents/Work/EXTRACT-BCC/EXTRACT-BCC/application-resources/jape/Micro_thickness.jape Rule Micro_thickness1 contains unlisted annotation type Micro_thickness_block
file:/C:/Users/huw.strafford/Documents/Work/EXTRACT-BCC/EXTRACT-BCC/application-resources/jape/Micro_thickness.jape Rule Micro_thickness2 contains unlisted annotation type Micro_thickness_block
file:/C:/Users/huw.strafford/Documents/Work/EXTRACT-BCC/EXTRACT-BCC/application-resources/jape/Margins.jape duplicate binding name n1 - ignoring this binding! exception was: gate.jape.JapeException: LeftHandSide.addBinding: n1 already bound
file:/C:/Users/huw.strafford/Documents/Work/EXTRACT-BCC/EXTRACT-BCC/application-resources/jape/Margins.jape duplicate binding name n1 - ignoring this binding! exception was: gate.jape.JapeException: LeftHandSide.addBinding: n1 already bound
file:/C:/Users/huw.strafford/Documents/Work/EXTRACT-BCC/EXTRACT-BCC/application-resources/jape/Margins.jape duplicate binding name n2 - ignoring this binding! exception was: gate.jape.JapeException: LeftHandSide.addBinding: n2 already bound
file:/C:/Users/huw.strafford/Documents/Work/EXTRACT-BCC/EXTRACT-BCC/application-resources/jape/Margins.jape duplicate binding name n2 - ignoring this binding! exception was: gate.jape.JapeException: LeftHandSide.addBinding: n2 already bound
file:/C:/Users/huw.strafford/Documents/Work/EXTRACT-BCC/EXTRACT-BCC/application-resources/jape/Margins.jape duplicate binding name n1 - ignoring this binding! exception was: gate.jape.JapeException: LeftHandSide.addBinding: n1 already bound
file:/C:/Users/huw.strafford/Documents/Work/EXTRACT-BCC/EXTRACT-BCC/application-resources/jape/Margins.jape duplicate binding name n2 - ignoring this binding! exception was: gate.jape.JapeException: LeftHandSide.addBinding: n2 already bound

*/

// The first two are because in Micro_thickness.jape (for the rules Micro_thickness1 and Micro_thickness2) you haven't added 'Micro_thickness_block' to the input at the top, but it is included in those two rules, it doesn't know what the 'Micro_thickness_block' is.
// The next 6 lines are about how you've used n1 and n2 mutiple times as a binding (the :n1 / :n2 in the LHS of the rules) - i will comment more in the rules itself.

// Commented here a fix to how to use just one n1(and n2) in the rules
// Used '[' (not '(') to make it easier to see
// Created one large n1 (and one large n2) the covers the whole of the measurement

/*    Deep

    [({Dimension})
    ({Micro_thickness})
    ({Token})?
    ({Separator})?
    ({ClockFace})?]
    [({Dimension})
    ({Micro_peripheral_margin})
    ({ClockFace})?]:n2

*/

/*   Peripheral 

    [({Dimension})
    ({Micro_peripheral_margin})
    ({Token})?
    ({Separator})?
    ({ClockFace})?]:n1
    [({Dimension})
    ({Micro_deep_margin})
    ({ClockFace})?]:n2

*/